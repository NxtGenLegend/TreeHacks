Zoom RTMS Overall
Architecture Design for Third-
Parties
Rene Ke Arun Janakiraman and 2 editors Updated at 18:48 01/22/2025 17 mins
Overview
This design documentation outlines the architecture, protocols, and message
formats for integrating the second-party and third-party apps with RTMS and covers
the following key aspects:
• Architecture Diagram
• Protocols between RTMS server and Second-Party or Third-Party
• Detailed message formats for various interactions
• Connection establishment process
• Security measures, including token verification
• Handling of media streams and participant events
• Error reporting and connection management
The subsequent chapters will explore the comprehensive architecture design and
interaction details of the first phase release. This section aims to offer a thorough
understanding of the system's structure and functionality. The workflow is
meticulously defined based on the server mode, ensuring optimal performance
and scalability. This approach facilitates efficient resource allocation and seamless
integration of various components within the system.
Terminology
RTMS: Real-Time Media Streams
2p: Second-Party - apps built by customer developers for internal use within their
organizations
3p: Third-Party - apps built by developers for publishing on Zoom marketplace
where anyone can use
RTP: Real-time Transport Protocol
MMR: Multi-Media Router
AAN: Active App Notifier
Service Model
The RTMS will support two types of service models: Server Mode and Client Mode.
Server Mode will serve as the default approach for 2p and 3p to communicate with
Zoom by adhering to protocols defined by Zoom.
• Server Mode: In this mode, the RTMS server operates as a server and provides
listening ports for various protocols, enabling 2p/3p to connect as clients and
transmit data.
• Client Mode: In this mode, the RTMS server functions as a client, establishing
connections to 2p or 3p socket servers or integrating with external SDKs to
facilitate data transmission.
Transmission Protocol
The RTMS will incorporate various protocols for data transmission, including
WebSocket, RTMP, UDP for media connection, SRT, and WebRTC. In the first
version, WebSocket will be prioritized for implementation on both signal and media
data connection, along with UDP for media data connection. Additional protocols
will be integrated in future releases.
Architecture Diagram
In the first version, the RTMS server will only support being invited to join a meeting
as a virtual client and subscribing to real-time events and media data within the
meeting.
Below are various interaction workflows. For more detailed information, please refer
to the ﻿ RTMS workflow whiteboard.
RTMS Object Structure
User Stories
Automatically Start RTMS
Note: automatically start case only supports the meeting original host.
• Recently, the administrator of Alice's organization added a third-party application
for all users on the Zoom Marketplace, which will use powerful AI models to
analyze media data of meetings to provide richer and more effective real-time
analysis results. On the web settings, the administrator enabled auto start RTMS
option on the application for all users.
• Alice started a meeting on the Zoom desktop client, and the MMR server will
check the meeting configurations from the meeting token, and found automatic
start option of the RTMS feature is enabled. Then, the MMR server calls the
Zoom Web API with the gateway ID and meeting ID to start the RTMS, and the
Zoom web will get application ID from the meeting original host settings and
generate a session ID respond back to the MMR.
• Next, the Zoom web then composes a join event (includes session ID and 3p
service type, etc.) and posts a message to the AsyncMQ.
• Then see ﻿ General Flows.
Manually Start RTMS
• Recently, the administrator of Alice's organization added a third-party application
for all users on the Zoom Marketplace, which will use powerful AI models to
analyze media data of meetings to provide richer and more effective real-time
analysis results.
• Alice started a meeting on the Zoom desktop client, and then she clicked the
"Apps" button on the bottom bar. In the list of apps on the right panel, Alice finds
the RTMS app and clicks it to open. Then, clicks the "Start" button on the app
WebView UI.
• When the meeting client receives this signal of the button click, as the design
flow, the meeting client will obtain the application ID (aka client ID) from Alice's
user information obtained from the Zoom web.
• The meeting client then takes the client ID as a parameter and calls the Zoom
Web API to get a gateway session ID, which will be sent to the meeting server
(MMR) to invite the RTMS server to join. Meanwhile, when the Zoom web
received the client ID, the Zoom web will verify it whether belongs to the user
who initiated this request.
• After finishing the verification, the Zoom web generates a session ID associated
with this request and responds to the meeting client. The meeting client then
calls the MMR function via the client SDK interface.
• After MMR receives this message, the MMR will send a RTMS server invitation
request to the Zoom web, the Zoom web then composes a join event (includes
session ID and 3p service type, etc.) and post a message to the AsyncMQ.
• Then see ﻿ General Flows.
General Flows
• This event will be sent to a RTMS server through the AsyncMQ agent (consume
topic) and the RTMS ZC. Once the join event is received, the RTMS server calls
the Zoom web "conf/gw/j" API to obtain a meeting token which is used to join
MMR. When the Zoom web received the API call from the RTMS server, it will
compose a response and send back.
◦ Besides the original parameters, the following parameters will also be added
into response. The signatures is a list containing hashes signed with all
client secrets (for covering secret rotate case).
1 userId == who initiated this request
2 clientID == the ID of the application on the Zoom marketplace
3 ownerId == the user ID associated with the application
4 accountId == the user's organization account ID
5 signatures == the hash list of the application info
• The RTMS server starts to join the meeting on MMR. After joining successfully, on
the meeting clients, participants will receive a disclaimer informing them that a
third-party application will acquire and transmit the meeting streams. Participants
have the option to opt out or remain in the meeting. On the backend, The RTMS
server produces a message and posts it to the AsyncMQ topic.
◦ The payload of the notification message includes the following parameters.
The server URL follows the standard pattern including protocol header, server
domain or IP, and port.
1 {
2 "eventType": "meeting.rtms.started"
,
3 "eventTime": 1732313171881,
4 "clientId": "xxxxxxxxxx"
,
5 "userId": "xxxxxxxxxx"
,
6 "accountId": "xxxxxxxxxx"
,
7 "payload": {
8 "event": "meeting.rtms.started"
,
9 "event
_
ts": 1732313171881,
10 "payload": {
11 "operator
_
id": "xxxxxxxxxx"
,
12 "object": {
13 "meeting_
uuid": "4444AAAiAAAAAiAiAiiAii==
"
,
14 "rtms
stream
_
_
id":
"609340fb2a7946909659956c8aa9250c"
,
15 "server
_
urls": "wss://127.0.0.1:443"
16 }
17 }
18 }
19 }
• The marketplace event service consumes this topic and subsequently looks up
the 2p or 3p service URL based on the client ID, user ID, and account ID. Upon
obtaining the service URL, the event service then sends a notification to the 2p
or 3p via Webhook.
◦ The notification event sent to 2p or 3p is as follows.
1 {
2 "event": "meeting.rtms.started"
,
3 "event
_
ts": 1732313171881,
4 "payload": {
5 "operator
_
id": "xxxxxxxxxx"
,
6 "object": {
7 "meeting_
uuid": "4444AAAiAAAAAiAiAiiAii==
"
8 "rtms
stream
_
_
id":
"609340fb2a7946909659956c8aa9250c"
,
9 "server
_
urls": "wss://127.0.0.1:443"
10 }
11 }
12 }
,
1 {
2 "event": "meeting.rtms.stopped"
,
3 "event
_
ts": 1732313171881,
4 "payload": {
5 "operator
_
id": "xxxxxxxxxx"
,
6 "object": {
7 "meeting_
uuid": "4444AAAiAAAAAiAiAiiAii==
"
8 "rtms
stream
_
_
id":
"609340fb2a7946909659956c8aa9250c"
9 }
10 }
11 }
,
• When the 2p or 3p service receives the RTMS started event, their clients can
establish a connection to the RTMS server using the server URL obtained from
the Zoom notification. After completing the TCP connection, the 2p or 3p client
must send a ﻿ SIGNALING
HAND
SHAKE
_
_
_
REQ message through the socket. The
payload of the message must include the meeting_
uuid , rtms
stream
_
_
id ,
and signature.
◦ The 2p or 3p will need to generate the signature by adhering to the following
structure then sign it with the client secret.
1 HMACSHA256(client
_
id + "
rtms
stream
_
_
id, secret);
,
" + meeting_
uuid + "
,
" +
• The RTMS server receives the signaling handshake message and will
◦ Firstly, verify the meeting_
uuid and rtms
stream
_
_
id whether they exist
on the current RTMS server. If not, terminate the connection immediately.
◦ Secondly, use the signature list sent by the Zoom web to compare and verify
the signature sent by the client. If the verification fails, respond with a
﻿ SIGNALING
HAND
SHAKE
_
_
_
RESP message containing a status code and reason,
terminate the connection to the 2p or 3p, send an error response to the upper
layer, and terminate the session and leave the meeting.
◦ Once the above verifications are passed, respond with a
﻿ SIGNALING
HAND
SHAKE
_
_
_
RESP message containing a media
server
_
information. In the first phase, the media server section only includes a
server
_
urls field, which lists all protocols supported by RTMS. The 2p and
3p can then select any one of these protocols to establish a connection.
◦ Meanwhile, RTMS server will send a ﻿ SESSION
STATE
_
_
UPDATE message
containing the session
_
id and state of STARTED through the signal
connection where informing the 2p or 3p that a new RTMS session is added
and started.
• The 2p or 3p must establish another connection for the media data transmission
to the RTMS server using the server URL obtained from the signaling handshake
response message. After completing the connection, the 2p or 3p client must
send a ﻿ DATA
HAND
SHAKE
_
_
_
REQ message to the RTMS server.
◦ The payload of the message must include the meeting_
uuid ,
rtms
stream
_
_
id , and signature which used in the signaling connection.
◦ The media
_
type is also must be included and it used to identify which type
of media data that you want to receive through this data connection. If the
value set to ALL , meaning all type of media data will be transmitting
through a single connection, however, it's not recommended. Zoom suggests
each type of media data through a separate connection.
◦ If developers want to encrypt the payload, the be set to true on each connection.
payload
_
encryption must
▪ Note: Even though the payload
_
encryption value is false but if the
transmission protocol is UDP, the payload still will be encrypted enforced.
◦ The media
_params is optional and used to define the parameters for
corresponding media type that the app wants to transmit in that connection.
▪ For audio data transmission
• The RTMS server supports transmitting mixed audio stream and
separate (active speakers) audio streams.
• The RTMS server will utilize the following media parameters as default
value. However, if the 2p or 3p requires a different one, they must
specify it in the request.
1 {
2 "content
_
type": RAW
_
AUDIO, // Refer to MEDIA
_
CONT
3 "sample
rate": SR
_
_
16K, // Refer to AUDIO
_
SAMP
4 "channel": MONO, // Refer to AUDIO
_
CHAN
5 "codec": L16, // Refer to MEDIA
_
PAYL
6 "data
_
opt": AUDIO
MIXED
_
_
STREAM, // Refer to MEDIA
_
DATA
7 "send
interval": 20
_
8 }
▪ For video data transmission
• In the V1, the RTMS server only supports transmitting active speaker
video stream. The data
_
opt will not be taken effect even if set to
other values.
• The RTMS server will utilize the following media parameters as default
value. However, if the 2p or 3p requires a different one, they must
specify it in the request.
1 {
2 "content
_
type": RAW
_
VIDEO, // Refer to MEDIA
CONTENT
_
_
T
3 "codec": JPG, // Refer to MEDIA
PAYLOAD
_
_
T
4 "resolution": HD, // Refer to MEDIA
_
RESOLUTIO
5 "fps": 5
6 }
• The RTMS server receives the data handshake message and will
a. Firstly, verify the meeting_
uuid , rtms
stream
_
_
id , and signature in
the same manner as the signaling flow.
b. Besides, if the media parameters are specified, the RTMS server will verify
each value. If any of the values are not allowed from the list, the RTMS server
will respond with a ﻿ DATA
HAND
SHAKE
_
_
_
RESP message, indicating a
STATUS
INVALID
MEDIA
_
_
_
PARAM status code and the reason for the 2p or 3p.
Subsequently, the RTMS server will wait for a new request for 5s, if no new
message is received within this timeframe, terminate the media connection
and corresponding signaling connection, respond with an error to the upper
layer, and then terminate the session and leave the meeting.
c. Once the above verifications are passed, respond with a
﻿ DATA
HAND
SHAKE
_
_
_
RESP message containing a STATUS
_
OK status code,
the sequence and the media
_params. Each value within the media
parameter represents the negotiated format that will be applied to the audio
data.
• At this point, once signaling and media connections established, the session
becomes fully active and operational. On the meeting clients, participants will
receive a toast notification indicating that the stream has started, while an
indicator (AAN) appears in the top right corner displaying the third-party
application and user who is acquiring the streams through the indicator panel.
Simultaneously, on the backend, a ﻿ STREAM
STATE
_
_
UPDATE message will be
transmitted, containing rtms
stream
_
_
id , the state of STARTED and the
timestamp of the first packet through the signaling connection. Meanwhile, the
data connection should be started to receive the media data.
• Once the whole connection establishment process is completed, 2p or 3p can
send a ﻿ EVENT
_
SUBSCRIPTION message to subscribe to or unsubscribe from
desired events.
◦ Currently, three event messages are supported for subscription or un-
subscription in the RTMS: ﻿ ACTIVE
SPEAKER
_
_
CHANGE , ﻿ PARTICIPANT
_
JOIN ,
and ﻿ PARTICIPANT
LEAVE .
_
◦ By default, if 2p or 3p chooses to receive the AUDIO
MIXED
_
_
STREAM , the
corresponding ﻿ ACTIVE
SPEAKER
_
_
CHANGE event will be sent out to 2p or 3p. If
2p or 3p chooses to receive the AUDIO
MIXED
_
_
STREAM , then the
﻿ PARTICIPANT
JOIN and ﻿ PARTICIPANT
LEAVE _
events will be sent out.
_
• To maintain the stability of the connections and prevent timeouts and
disconnections, the RTMS server sends a ﻿ KEEP
ALIVE
_
_
REQ message and the
2p or 3p must respond with a ﻿ KEEP
ALIVE
_
_
RESP message.
◦ In the signaling connection, the keep-alive request is sent every 5 seconds if
the last message sends time exceeds 5 seconds. As a result, the 2p or 3p
client must respond before the next keep-alive message arrives. If three
consecutive keep-alive messages remain unanswered, the RTMS server will
terminate both signaling and media connections, report an error to the upper
layer, and subsequently leave the meeting.
◦ In the media connection, if the last data packet transmission time exceeds 5
seconds or the stream status is PAUSED, the RTMS server actively sends a
keep-alive request. Subsequently, if three consecutive keep-alive messages
remain unanswered, the RTMS server will terminate both signaling and media
connections, report an error to the upper layer, and then leave the meeting.
• When users pause/resume/stop the RTMS stream, RTMS server will send a
﻿ SESSION
STATE
_
_
UPDATE message containing the session
id and state of
_
PAUSED or RESUMED or STOPPED through the signal connection where
informing the 2p or 3p that a RTMS session state has changed.
• Once all sessions have been terminated, RTMS server will send a
﻿ STREAM
STATE
_
_
UPDATE message that includes the rtms
stream
_
_
id , the state
of STOPPED with stop_
reason , and the timestamp that indicating a
particular stream has completely ended.
Data Type Definitions
1 enum RTMS
MESSAGE
TYPE
_
_
2 {
3 UNKNOWN,
4 SIGNALING
HAND
SHAKE
_
_
_
5 SIGNALING
HAND
SHAKE
_
_
_
6 DATA
HAND
SHAKE
_
_
_
REQ, 7 DATA
HAND
SHAKE
_
_
_
RESP, 8 EVENT
_
SUBSCRIPTION, 9 EVENT
_
UPDATE, 10 STREAM
STATE
_
_
UPDATE, 11 SESSION
STATE
_
_
UPDATE, 12 SESSION
STATE
_
_
REQ, 13 SESSION
STATE
_
_
RESP, 14 KEEP
ALIVE
_
_
REQ, 15 KEEP
ALIVE
_
_
RESP, 16 MEDIA
DATA
_
_
AUDIO, 17 MEDIA
DATA
_
_
VIDEO, 18 MEDIA
DATA
_
_
SHARE, 19 MEDIA
DATA
_
_
CHAT, 20 MEDIA
DATA
_
_
TRANSCRIPT 21 }
REQ, // Initializes the signaling connection
RESP, // Indicates the response of initialed
// Initializes the media data connectio
// Indicates the response of initialed
// Indicates which events want to subsc
// Indicates a specific event happens,
// Indicates the stream state changed,
// Indicates the session state updated,
// Indicates querying the session state
// Indicates the response of session st
// Indicates it is a keep-alive request
// Indicates it is a keep-alive respons
// Indicates audio data is being transm
// Indicates video data is being transm
// Indicates sharing data is being tran
// Indicates the meeting chat messages
// Indicates the transcripts of meeting
1 enum RTMS
EVENT
TYPE
_
_
2 {
3 ACTIVE
SPEAKER
_
_
CHANGE, // Indicates who the most recent active spe
4 PARTICIPANT
_
JOIN, // Indicates a new participant joined this
5 PARTICIPANT
_
LEAVE // Indicates a participant is leaving this
6 }
1 enum RTMS
STATUS
CODE
_
_
2 {
3 STATUS
_
OK,
4 STATUS
CONNECTION
_
_
TIMEOUT,
5 STATUS
INVALID
JSON
_
_
_
MSG,
6 STATUS
INVALID
MESSAGE
_
_
_
TYPE,
7 STATUS
MSG
TYPE
NOT
_
_
_
_
EXIST,
8 STATUS
MSG
TYPE
NOT
_
_
_
_
UINT,
9 STATUS
MEETING
UUID
NOT
_
_
_
_
EXIST,
10 STATUS
MEETING
UUID
IS
_
_
_
_
EMPTY,
11 STATUS
RTMS
STREAM
ID
NOT
_
_
_
_
_
EXIST,
12 STATUS
RTMS
STREAM
ID
IS
_
_
_
_
_
EMPTY,
13 STATUS
SESSION
NOT
_
_
_
FOUND,
14 STATUS
SIGNATURE
NOT
_
_
_
EXIST,
15 STATUS
INVALID
_
_
SIGNATURE,
16 STATUS
INVALID
MEETING
OR
STREAM
_
_
_
_
_
ID,
17 STATUS
DUPLICATE
SIGNAL
_
_
_
REQUEST,
18 STATUS
MEDIA
TYPE
NOT
_
_
_
_
EXIST,
19 STATUS
MEDIA
TYPE
NOT
_
_
_
_
UINT,
20 STATUS
MEDIA
DATA
ALL
CONNECTION
_
_
_
_
_
EXIST,
21 STATUS
DUPLICATE
MEDIA
DATA
_
_
_
_
CONNECTION,
22 STATUS
MEDIA
PARAMS
NOT
_
_
_
_
EXIST,
23 STATUS
INVALID
MEDIA
_
_
_
PARAMS,
24 STATUS
NO
MEDIA
TYPE
_
_
_
_
SPECIFIED,
25 STATUS
INVALID
MEDIA
AUDIO
_
_
_
_
PARAMS,
26 STATUS
MEDIA
AUDIO
CONTENT
TYPE
NOT
_
_
_
_
_
_
UINT,
27 STATUS
INVALID
MEDIA
AUDIO
CONTENT
_
_
_
_
_
TYPE,
28 STATUS
MEDIA
AUDIO
SAMPLE
RATE
NOT
_
_
_
_
_
_
UINT,
29 STATUS
INVALID
MEDIA
AUDIO
SAMPLE
_
_
_
_
_
RATE,
30 STATUS
MEDIA
AUDIO
CHANNEL
NOT
_
_
_
_
_
UINT,
31 STATUS
INVALID
MEDIA
AUDIO
_
_
_
_
CHANNEL,
32 STATUS
MEDIA
AUDIO
CODEC
NOT
_
_
_
_
_
UINT,
33 STATUS
INVALID
MEDIA
AUDIO
_
_
_
_
CODEC,
34 STATUS
MEDIA
AUDIO
DATA
OPT
NOT
_
_
_
_
_
_
UINT,
35 STATUS
INVALID
MEDIA
AUDIO
DATA
_
_
_
_
_
OPT,
36 STATUS
MEDIA
AUDIO
SEND
INTERVAL
NOT
_
_
_
_
_
_
37 STATUS
MEDIA
AUDIO
COMBINE
FRAME
NOT
_
_
_
_
_
_
38 STATUS
INVALID
MEDIA
VIDEO
_
_
_
_
PARAMS,
39 STATUS
INVALID
MEDIA
SHARE
_
_
_
_
PARAMS,
40 STATUS
INVALID
AUDIO
DATA
_
_
_
_
BUFFER,
41 STATUS
POST
FIRST
PACKET
FAILURE
_
_
_
_
42 }
UINT,
BOOL,
1 enum RTMS
SESSION
STATE
_
_
2 {
3 INACTIVE, // Default state
4 INITIALIZE, // A new session is initializing
5 STARTED, // A new Session is started
6 PAUSED, // A session is paused
7 RESUMED, // A session is resumed
8 STOPPED // A session is stopped
9 }
1 enum RTMS
STREAM
STATE
_
_
2 {
3 INACTIVE, // Default state
4 ACTIVE, // Media data has started to transmit
5 TERMINATED, // Stream is terminated, e.g. all sessions are
stopped or meeting is ended
6 INTERRUPTED // Signal or any data connections encountered a
problem
7 }
1 enum RTMS
STOP
REASON
_
_
2 {
3 UNKNOWN,
4 // Stopped when triggered by host, returned on session update mess
5 STOP
BC
HOST
_
_
_
TRIGGERED,
6 // Stopped when triggered by userself, returned on session update
7 STOP
BC
USER
_
_
_
TRIGGERED,
8 // Stopped when app user left meeting, returned on session update
9 STOP
BC
USER
_
_
_
LEFT,
10 // Stopped when app user ejected by meeting host, returned on sess
11 STOP
BC
USER
_
_
_
EJECTED,
12 // Stopped when host disabled app user or entire app in the meetin
13 STOP
BC
APP
DISABLED
BY
_
_
_
_
_
HOST,
14 // Stopped when meeting is ended, returned on stream update messag
15 STOP
BC
MEETING
_
_
_
ENDED,
16 // Stopped when stream canceled by participant request, returned o
17 STOP
BC
STREAM
_
_
_
CANCELED,
18 // Stopped when host disabled all apps in the meeting, returned on
19 STOP
BC
ALL
APPS
_
_
_
_
DISABLED,
20 // Stopped if any internal exceptions, e.g. post asyncmq message f
21 STOP
BC
INTERNAL
_
_
_
EXCEPTION,
22 // Stopped when the connection timed out, returned on stream updat
23 STOP
BC
CONNECTION
_
_
_
TIMEOUT,
24 // Stopped when a connection interrupted, returned on stream updat
25 STOP
BC
CONNECTION
_
_
_
INTERRUPTED,
26 // Stopped when a connection closded by app, returned on stream up
27 STOP
BC
CONNECTION
CLOSED
BY
_
_
_
_
_
CLIENT,
28 // Stopped when received exit signal, returned on stream update me
29 STOP
BC
EXIT
SIGNAL
_
_
_
30 }
1 enum MEDIA
CONTENT
TYPE
_
_
2 {
3 RTP = 1, // Real-time audio and video
4 RAW
_
AUDIO, // Real-time audio
5 RAW
_
VIDEO, // Real-time video
6 FILE
_
STREAM, // File stream
7 TEXT // Media data is text based, such as Chat messages
and Transcripts
8 }
1 enum MEDIA
PAYLOAD
TYPE
_
_
2 {
3 L16 = 1, // Audio, uncompressed raw data
4 PCMA, // Audio
5 PCMU, // Audio
6 G722, // Audio
7 OPUS, // Audio
8 JPG, // Video and Sharing, when fps <= 5
9 H264 // Video and Sharing, when fps > 5
10 }
1 enum MEDIA
DATA
TYPE
_
_
2 {
3 AUDIO = 1,
4 VIDEO,
5 DESKSHARE,
6 TRANSCRIPT,
7 CHAT,
8 ALL
9 }
1 enum MEDIA
DATA
OPTION
_
_
2 {
3 AUDIO
MIXED
_
_
STREAM = 1, // Data is mixed audio stream
4 AUDIO
MULTI
_
_
STREAMS, // Data is audio stream(s) of active
speaker(s)
5 VIDEO
SINGLE
ACTIVE
_
_
_
STREAM, // Data is single video stream of
active speaker
6 VIDEO
MIXED
SPEAKER
_
_
_
VIEW, // Data is mixed video stream using
speaker view
7 VIDEO
MIXED
GALLERY
_
_
_
VIEW // Data is mixed video stream using
gallery view
8 }
1 enum MEDIA
RESOLUTION
_
2 {
3 SD = 1, // 480p or 360p, 854x480 or 640x360
4 HD, // 720p, 1280 x 720
5 FHD, // 1080p, 1920 x 1080
6 QHD // 2K, 2560 x 1440
7 }
1 enum AUDIO
SAMPLE
RATE
_
_
2 {
3 SR
_
16K = 1,
4 SR
_
32K,
5 SR
48K
_
6 }
1 enum AUDIO
CHANNEL
_
2 {
3 MONO = 1,
4 STEREO
5 }
1 enum TRANSMISSION
PROTOCOL
_
2 {
3 WEBSOCKET = 1,
4 RTMP,
5 UDP,
6 WEBRTC
7 }
Messages
This section defines interactive messages including signaling and media data.
Signaling and Meta-Data
The request message for the signaling handshake
1 {
2 "msg_
type": SIGNALING
HAND
_
_
SHAKE
REQ,
3 "protocol
_
version": 1,
4 "meeting_
uuid": "xxxxxxxxxx"
,
5 "rtms
stream
id": "xxxxxxxxxx"
_
_
6 "signature": "xxxxxxxxxx"
7 }
_
,
The response message for the signaling handshake
1 {
2 "msg_
type": SIGNALING
HAND
SHAKE
_
_
_
RESP,
3 "protocol
_
version": 1,
4 "status
code": STATUS
_
_
OK, // If the status is not STATUS
_
OK (0) me
5 "reason": ""
, // If the status is failed, the reason will be fille
6 "media
_
server": {
7 "server
_
urls": {
8 "audio": "wss://0.0.0.0:443,udp://0.0.0.0:8801"
,
9 "video": "wss://0.0.0.0:443,udp://0.0.0.0:8801"
,
10 "transcript": "wss://0.0.0.0:443"
,
11 "all": "wss://0.0.0.0:443"
12 },
13 "srtp_
keys": {
14 "audio": "xxxxxxxxxx"
,
15 "video": "xxxxxxxxxx"
,
16 "share": "xxxxxxxxxx"
17 }
18 }
19 }
The message for subscribing or unsubscribing stream events
1 {
2 "msg_
type": EVENT
_
SUBSCRIPTION,
3 "events": [
4 {
5 "event
_
type": ACTIVE
SPEAKER
_
_
CHANGE,
6 "subscribe": true|false // true means subscribe, false mea
7 },
8 {
9 "event
_
type": PARTICIPANT
_
JOIN,
10 "subscribe": true
11 },
12 {
13 "event
_
type": PARTICIPANT
_
LEAVE,
14 "subscribe": false
15 }
16 ]
17 }
• This message does not require a response.
• Currently, only ACTIVE
SPEAKER
_
_
CHANGE , PARTICIPANT
_
JOIN , and
PARTICIPANT
_
LEAVE three events are supported.
The message for updating stream state
1 {
2 "msg_
type": STREAM
STATE
_
_
UPDATE,
3 "rtms
stream
id": "xxxxxxxxxx"
_
_
,
4 "state": ACTIVE|TERMINATED, // Refer to RTMS
_
STREAM
5 "reason": STOP
BC
MEETING
_
_
_
ENDED, // Refer to RTMS
STOP
_
_
6 "timestamp": 1727384349123
7 }
STATE def
_
REASON defi
• The STARTED has been transmitted.
state update message will be sent when the first media packet
• The STOPPED state update message will be sent when the stream needs to be
stopped, such as, the session(s) associated with this stream are ended, or
meeting is closed, or other exceptional cases.
• This message does not require a response.
The message for updating session state
1 {
2 "msg_
type": SESSION
STATE
_
_
UPDATE,
3 "session
id": "xxxxxxxxxx"
_
,
4 "state": STARTED|PAUSED|RESUMED|STOPPED,
5 "stop_
reason": ACTION
BY
_
_
HOST|ACTION
BY
_
_
USER, // Refer to RTMS
_
STO
6 "timestamp": 1727384349123
7 }
• This message does not require a response.
The request message for querying the current session state
1 {
2 "msg_
type": SESSION
STATE
_
_
3 "session
id": "xxxxxxxxxx"
_
4 }
REQ,
• The current session state can be queried by • The RTMS server will reply with a message of type " containing the current session state.
session
id.
_
SESSION
STATE
_
_
RESP "
The response message for the current session state request
1 {
2 "msg_
type": SESSION
STATE
_
_
RESP,
3 "session
id": "xxxxxxxxxx"
_
,
4 "session
_
state": STARTED|PAUSED|RESUMED
5 }
The message of the meta-data for the active speaker change
1 {
2 "msg_
type": EVENT
_
UPDATE,
3 "event": {
4 "event
_
type": ACTIVE
SPEAKER
_
_
CHANGE,
5 "current
_
id": 0|11223344, // If current
id is 0 means it's fir
_
6 "new
_
id": 22334455,
7 "name": "John Smith"
,
8 "timestamp": 11111111111
9 }
10 }
• This message does not require a response.
The message of the meta-data for the participant events
1 {
2 "msg_
type": EVENT
_
UPDATE,
3 "event": {
4 "event
_
type": PARTICIPANT
_
JOIN,
5 "participants": [
6 {
7 "user
_
id": 16778240, 8 "name": "John Smith" 9 },
10 {
11 "user
_
id": 33556610,
12 "name": "Alice"
13 }
14 ]
15 }
16 }
// The unique participant id in
// User display name in the mee
1 {
2 "msg_
type": EVENT
_
UPDATE,
3 "event": {
4 "event
_
type": PARTICIPANT
_
LEAVE,
5 "participants": [16778240, 33556610] // The user
_
id list of wh
6 }
7 }
• By default, PARTICIPANT
JOIN and PARTICIPANT
_
_
LEAVE third parties if AUDIO
MULTI
_
_
STREAMS is being selected.
• These messages do not require a response.
events will be sent to
The message of the keep-alive request
1 {
2 "msg_
type": KEEP
ALIVE
_
_
REQ,
3 "sequence": 0,
4 "timestamp": 1727384349123
5 }
• The sequence number has to be presented in the response.
The response message of the keep-alive request
1 {
2 "msg_
type": KEEP
ALIVE
_
_
RESP,
3 "sequence": 0,
4 "timestamp": 1727384349123 // this timestamp is the request timest
5 }
Media Data
The request message for the data handshake
1 {
2 "msg_
type": DATA
HAND
SHAKE
_
_
_
REQ,
3 "protocol
_
version": 1,
4 "sequence": 0,
5 "meeting_
uuid": "xxxxxxxxxx"
,
6 "rtms
stream
id": "xxxxxxxxxx"
_
_
,
7 "signature": "xxxxxxxxxx"
,
8 /*
9 * Refer to MEDIA
DATA
TYPE definition. If the value set to "ALL"
_
_
,
10 * meaning all media category data where the app supported will be
11 * transmitted through one socket connection.
12 */
13 "media
_
type": AUDIO|VIDEO|TRANSCRIPT|ALL,
14 /*
15 * The default value is false (0) for any TLS connection, and the
16 * encryption keys are provided in the signal hand shake resp.
17 * - If parameter value is true (1) means the payload will be enc
18 * - If parameter value is false (0) but the transmission protoco
19 * the payload still will be encrypted enforced
20 */
21 "payload
_
encryption": true|false,
22 /*
23 * Optional, the params will be set to default value if not specif
24 * and return in the DATA
HAND
SHAKE
_
_
_
RESP message
25 */
26 "media
_params": {
27 "audio": {
28 "content
_
type": RAW
_
AUDIO, // Refer to MEDIA
CONTENT
_
_
29 "sample
rate": SR
_
_
16K, // Refer to AUDIO
SAMPLE
_
_
R
30 "channel": MONO, // Refer to AUDIO
_
CHANNEL
31 "codec": L16, // Refer to MEDIA
PAYLOAD
_
_
32 "data
_
opt": AUDIO
MIXED
_
_
STREAM, // Refer to MEDIA
DATA
_
_
OPT
33 "send
_
rate": 100 // Sending rate, must be multiple of 20
34 },
35 "video": {
36 "codec": JPG, // Refer to MEDIA
PAYLOAD
TYPE definitio
_
_
37 "resolution": HD, // Refer to MEDIA
RESOLUTION definitions
_
38 "fps": 5
39 }
40 }
41 }
The response message for the data handshake
1 {
2 "msg_
type": DATA
HAND
SHAKE
_
_
_
RESP,
3 "protocol
_
version": 1,
4 "status
code": STATUS
_
_
OK, // If the status is not STATUS
_
OK meanin
5 "reason": ""
, // If the status is failed, the reason will be fille
6 "sequence": 0,
7 "payload
_
encrypted": true|false, // For UDP, the payload will be e
8 "media
_params": {
9 "audio": {
10 "content
_
type": RAW
_
AUDIO, // Refer to MEDIA
CONTENT
_
_
11 "sample
rate": SR
_
_
16K, // refer to AUDIO
SAMPLE
_
_
R
12 "channel": MONO, // refer to AUDIO
_
CHANNEL
13 "codec": L16, // refer to MEDIA
PAYLOAD
_
_
14 "data
_
opt": AUDIO
MIXED
_
_
STREAM, // Refer to MEDIA
DATA
_
_
OPT
15 "send
_
rate": 100 // Sending rate, must be multiple of 20
16 },
17 "video": {
18 "content
_
type": RAW
_
VIDEO,
19 "codec": JPG, // Refer to MEDIA
PAYLOAD
TYPE definitio
_
_
20 "resolution": HD, // Refer to MEDIA
RESOLUTION definition
_
21 "fps": 5
22 },
23 "transcript": {
24 "content
_
type": TEXT
25 }
26 }
27 }
The message of sending audio data
Note: If developers select AUDIO
MULTI
_
_
STREAMS user's audio data will be transmitted through different messages.
, then within a fixed interval, each
1 {
2 "msg_
type": MEDIA
DATA
_
_
AUDIO, // Media p is raw
3 "content": {
4 "user
_
id": 16778240|0, // if user
_
id is 0, means the packet is
5 "data": (media packet),
6 "timestamp": 1111111111,
7 }
8 }
1 {
2 "msg_
type": MEDIA
DATA
_
_
AUDIO, // Media data packs by RTP
3 "content": {
4 "data": (media packet)
5 }
6 }
The message of video data
1 {
2 "msg_
type": MEDIA
DATA
_
_
VIDEO,
3 "content": {
4 "user
_
id": 16778240,
5 "data": (media packet)
6 }
7 }
The message of chat and transcript data
Note: Each user's transcript data will be transmitted through different messages.
1 {
2 "msg_
type": MEDIA
DATA
_
_
CHAT|MEDIA
DATA
_
_
3 "content": {
4 "user
_
id": 19778240,
5 "timestamp": 1727384349000,
6 "data": "xxxxxxxxxx"
7 }
8 }
TRANSCRIPT,
Failover
Connection Broken between RTMS and MMR
When the connection between the RTMS server and MMR server is broken, the
RTMS server will try to rejoin with old meeting parameters. Meanwhile, the MMR will
also re-invite the RTMS server to join the meeting.
• If the rejoin request reaches the MMR server first, the MMR will reject the re-
invite request. After the rejoin successfully, nothing impact on the connections
between the RTMS and 2p and 3p. The RTMS server will continue to send the
media packets.
• If the re-invite request reaches the MMR server first, MMR will reject the rejoin
request. The old RTMS server will then terminate the connection and delete all
information about the conference and session from the server.
Connection Broken between RTMS and Receiver
When the connection between the RTMS server and receiver is broken, the RTMS
server will send a new invitation message with old parameters. In the meantime, the
receiver may establish a new connection. No matter which one reaches the RTMS
server first, the RTMS server will only proceed with the first connection and reject
the second one.
RTMS Server Selection Mechanism
To simplify the regional RTMS server selection mechanism, the following strategies
are currently used.
• If the RTMS has a zone configured in the Data Center where the meeting top
MMR is located, prioritize the RTMS zone corresponding to the meeting top MMR
zone, Zoom web chooses up to 3 zones and posts the invitation messages.
• If the RTMS does not have a zone configured in the Data Center where the
meeting top MMR is located (not US), prioritize and return the RTMS zone in the
Data Center of US first, Zoom web chooses up to 3 zones and posts the invitation
messages.
• If the RTMS does not have a zone configured in the Data Center where the
meeting top MMR is located (non-US), and the US is not in the list of countries
allowed by the meeting original host, then up to 3 zones are randomly selected
from the datacenters where RTMS is deployed.